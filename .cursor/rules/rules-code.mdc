---
alwaysApply: true
---

# Zuno Marketplace Contracts - Cursor Rules

## üöÄ **COMMIT MESSAGE RULES**

### Conventional Commits Format

```
<type>(<scope>): <description>\n\n<body>\n\n<footer>
```

### Type Rules

- **feat**: New feature
- **fix**: Bug fix
- **docs**: Documentation changes
- **style**: Code style changes (formatting, etc.)
- **refactor**: Code refactoring without changing functionality
- **perf**: Performance improvements (gas optimization)
- **test**: Adding or updating tests
- **chore**: Maintenance tasks, dependencies
- **contract**: Smart contract specific changes
- **deploy**: Deployment scripts
- **security**: Security improvements

### Scope Rules (Optional but recommended)

- **exchange**: Exchange contracts (ERC721/ERC1155)
- **collection**: Collection contracts
- **auction**: Auction contracts
- **fees**: Fee management
- **security**: Security features (timelock, emergency)
- **factory**: Factory contracts
- **libraries**: Library functions
- **validation**: Validation logic
- **access**: Access control
- **deploy**: Deployment scripts

### Description Rules

- Use imperative mood: "add", "fix", "update", "remove"
- Start with lowercase letter
- No period at the end
- Maximum 50 characters
- Be clear and concise

### Body Rules

- **MANDATORY**: Each line maximum 100 characters
- Explain WHAT and WHY, not HOW
- Use bullet points for multiple changes
- Leave blank line between header and body
- Leave blank line between body and footer

### Footer Rules (Optional)

- Reference issues: `Closes #123`, `Fixes #456`
- Breaking changes: `BREAKING CHANGE: description`
- Co-authors: `Co-authored-by: Name <email>`

## ‚úÖ **GOOD EXAMPLES**

```bash
# Simple feature
feat(exchange): add ERC1155 batch listing support

# Feature with body
feat(auction): implement dutch auction mechanism\n\n- Add price decay calculation\n- Add time-based price updates\n- Add buyer purchase validation\n- Update auction finalization logic

# Bug fix
fix(security): resolve reentrancy vulnerability in payment distribution\n\n- Add ReentrancyGuard to buyNFT function\n- Update payment order to prevent attack\n- Add comprehensive test coverage

# Gas optimization
perf(libraries): optimize payment distribution gas usage\n\n- Reduce storage reads by caching values\n- Combine multiple transfers into single operation\n- Remove redundant calculations
```

## ‚ùå **BAD EXAMPLES**

```bash
# Too long header
feat(exchange): implement comprehensive ERC1155 exchange with batch operations and advanced features

# Missing type
exchange: add listing functionality

# Wrong format
Added new auction feature
```

## üèóÔ∏è **ARCHITECTURE & STRUCTURE**

### Project Organization

```
src/
‚îú‚îÄ‚îÄ common/              # Base contracts (BaseNFTExchange, BaseCollection, Fee)
‚îú‚îÄ‚îÄ core/               # Core marketplace contracts
‚îÇ   ‚îú‚îÄ‚îÄ access/         # Access control (MarketplaceAccessControl)
‚îÇ   ‚îú‚îÄ‚îÄ analytics/      # Analytics tracking
‚îÇ   ‚îú‚îÄ‚îÄ auction/        # Auction mechanisms
‚îÇ   ‚îú‚îÄ‚îÄ collection/     # Collection contracts
‚îÇ   ‚îú‚îÄ‚îÄ exchange/       # Exchange contracts
‚îÇ   ‚îú‚îÄ‚îÄ factory/        # Factory contracts
‚îÇ   ‚îú‚îÄ‚îÄ fees/           # Fee management
‚îÇ   ‚îú‚îÄ‚îÄ listing/        # Listing management
‚îÇ   ‚îú‚îÄ‚îÄ offers/         # Offer system
‚îÇ   ‚îú‚îÄ‚îÄ proxy/          # Proxy patterns
‚îÇ   ‚îú‚îÄ‚îÄ security/       # Security features
‚îÇ   ‚îî‚îÄ‚îÄ validation/     # Validation logic
‚îú‚îÄ‚îÄ libraries/          # Reusable libraries
‚îú‚îÄ‚îÄ interfaces/         # Contract interfaces
‚îú‚îÄ‚îÄ events/            # Event definitions
‚îú‚îÄ‚îÄ errors/            # Custom error definitions
‚îî‚îÄ‚îÄ types/             # Struct definitions

test/
‚îú‚îÄ‚îÄ unit/              # Unit tests
‚îú‚îÄ‚îÄ integration/       # Integration tests
‚îú‚îÄ‚îÄ mocks/            # Mock contracts
‚îî‚îÄ‚îÄ utils/            # Test helpers

script/
‚îî‚îÄ‚îÄ deploy/           # Deployment scripts
```

### Import Conventions

- **ALWAYS** use `@openzeppelin/contracts` for OpenZeppelin imports
- Group imports: External packages ‚Üí Interfaces ‚Üí Internal modules ‚Üí Libraries ‚Üí Events/Errors
- Use consistent import order for better readability

```solidity
// ‚úÖ CORRECT
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import {IExchangeCore} from "src/interfaces/IMarketplaceCore.sol";
import {BaseNFTExchange} from "src/common/BaseNFTExchange.sol";
import {PaymentDistributionLib} from "src/libraries/PaymentDistributionLib.sol";
import "src/events/NFTExchangeEvents.sol";
import "src/errors/NFTExchangeErrors.sol";

// ‚ùå WRONG
import "src/errors/NFTExchangeErrors.sol";
import {BaseNFTExchange} from "src/common/BaseNFTExchange.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
```

## üéØ **SOLIDITY BEST PRACTICES**

### Contract Structure Order

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

// 1. Imports
import "@openzeppelin/contracts/...";

// 2. Contract definition
contract ContractName is Parent1, Parent2 {
    // 3. Type declarations (enums, structs)
    enum Status { Active, Inactive }
    struct Data { ... }

    // 4. State variables
    uint256 public constant CONSTANT_VALUE = 100;
    uint256 public s_stateVariable;
    mapping(address => uint256) public s_mapping;

    // 5. Events
    event SomethingHappened(address indexed user, uint256 amount);

    // 6. Modifiers
    modifier onlyActive() { ... }

    // 7. Constructor
    constructor() { ... }

    // 8. External functions
    function externalFunction() external { ... }

    // 9. Public functions
    function publicFunction() public { ... }

    // 10. Internal functions
    function _internalFunction() internal { ... }

    // 11. Private functions
    function _privateFunction() private { ... }

    // 12. View/Pure functions
    function getterFunction() public view returns (uint256) { ... }
}
```

### Naming Conventions

```solidity
// State variables: s_ prefix
uint256 public s_takerFee;
mapping(bytes32 => Listing) public s_listings;
address public s_marketplaceWallet;

// Function parameters: m_ prefix
function createListing(address m_contractAddress, uint256 m_tokenId) external {
    // Implementation
}

// Internal/Private functions: _ prefix
function _generateListingId() internal view returns (bytes32) {
    // Implementation
}

// Constants: UPPER_SNAKE_CASE
uint256 public constant BPS_DENOMINATOR = 10000;
uint256 public constant MAX_FEE_BPS = 1000;

// Events: PascalCase with descriptive names
event NFTListed(bytes32 indexed listingId, address indexed seller);

// Errors: ContractName__ErrorDescription
error NFTExchange__InvalidMarketplaceWallet();
error NFTExchange__NFTNotActive();
```

### Custom Error Patterns

```solidity
// ‚úÖ CORRECT: Descriptive custom errors
error NFTExchange__InvalidMarketplaceWallet();
error NFTExchange__NFTNotActive();
error NFTExchange__InsufficientPayment();
error Collection__MintLimitExceeded();
error Auction__BidTooLow();

// ‚ùå WRONG: Generic errors
error InvalidInput();
error Failed();
revert("Invalid input");
```

### Event Patterns

```solidity
// ‚úÖ CORRECT: Indexed key parameters
event NFTListed(
    bytes32 indexed listingId,
    address indexed contractAddress,
    uint256 indexed tokenId,
    address seller,
    uint256 price
);

// ‚úÖ CORRECT: State change events
event MarketplaceWalletUpdated(address indexed oldWallet, address indexed newWallet);
event TakerFeeUpdated(uint256 oldFee, uint256 newFee);

// ‚ùå WRONG: Missing indexed parameters
event NFTListed(bytes32 listingId, address seller, uint256 price);
```

## üìö **LIBRARY PATTERNS**

### Library Structure

```solidity
// ‚úÖ CORRECT: Comprehensive library with errors, events, structs
library PaymentDistributionLib {
    // Errors
    error PaymentDistribution__InsufficientBalance();
    error PaymentDistribution__TransferFailed();

    // Events
    event PaymentDistributed(address indexed seller, uint256 amount);

    // Structs
    struct PaymentData {
        address seller;
        uint256 amount;
    }

    // Functions
    function distributePayment(PaymentData memory data) internal {
        // Implementation
    }
}

// ‚úÖ CORRECT: Using library
import {PaymentDistributionLib} from "src/libraries/PaymentDistributionLib.sol";

PaymentDistributionLib.PaymentData memory data = PaymentDistributionLib.PaymentData({
    seller: seller,
    amount: amount
});
PaymentDistributionLib.distributePayment(data);
```

### Common Libraries

- **PaymentDistributionLib**: Payment distribution logic
- **RoyaltyLib**: Royalty calculation (EIP-2981)
- **ArrayUtilsLib**: Array manipulation utilities
- **AuctionUtilsLib**: Auction-specific utilities
- **NFTTransferLib**: Safe NFT transfer logic
- **NFTValidationLib**: NFT validation checks

## üîí **SECURITY PATTERNS**

### Access Control

```solidity
// ‚úÖ CORRECT: Use OpenZeppelin Ownable
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract MyContract is Ownable {
    constructor() Ownable(msg.sender) {}

    function adminFunction() external onlyOwner {
        // Implementation
    }
}
```

### Reentrancy Protection

```solidity
// ‚úÖ CORRECT: Checks-Effects-Interactions pattern
function buyNFT(bytes32 m_listingId) external payable {
    // 1. Checks
    if (s_listings[m_listingId].status != ListingStatus.Active) {
        revert NFTExchange__NFTNotActive();
    }
    if (msg.value < requiredPayment) {
        revert NFTExchange__InsufficientPayment();
    }

    // 2. Effects
    s_listings[m_listingId].status = ListingStatus.Sold;
    delete s_activeListings[contractAddress][tokenId][seller];

    // 3. Interactions
    IERC721(contractAddress).transferFrom(seller, msg.sender, tokenId);
    _distributePayments(paymentData);
}
```

### Input Validation

```solidity
// ‚úÖ CORRECT: Validate all inputs
function updateMarketplaceWallet(address m_newMarketplaceWallet) external onlyOwner {
    if (m_newMarketplaceWallet == address(0)) {
        revert NFTExchange__InvalidMarketplaceWallet();
    }
    address oldWallet = s_marketplaceWallet;
    s_marketplaceWallet = m_newMarketplaceWallet;
    emit MarketplaceWalletUpdated(oldWallet, m_newMarketplaceWallet);
}

function updateTakerFee(uint256 m_newTakerFee) external onlyOwner {
    if (m_newTakerFee > BPS_DENOMINATOR) {
        revert NFTExchange__InvalidTakerFee();
    }
    uint256 oldFee = s_takerFee;
    s_takerFee = m_newTakerFee;
    emit TakerFeeUpdated(oldFee, m_newTakerFee);
}
```

### Safe Transfers

```solidity
// ‚úÖ CORRECT: Safe transfer with error handling
function _safeTransfer(address to, uint256 amount) private {
    if (address(this).balance < amount) {
        revert PaymentDistribution__InsufficientBalance();
    }

    (bool success,) = payable(to).call{value: amount}("");
    if (!success) {
        revert PaymentDistribution__TransferFailed();
    }
}

// ‚úÖ CORRECT: NFT transfer with approval check
function _transferNFT(address from, address to, address nftContract, uint256 tokenId) internal {
    if (!IERC721(nftContract).isApprovedForAll(from, address(this))) {
        if (IERC721(nftContract).getApproved(tokenId) != address(this)) {
            revert NFTExchange__MarketplaceNotApproved();
        }
    }
    IERC721(nftContract).transferFrom(from, to, tokenId);
}
```

## ‚õΩ **GAS OPTIMIZATION**

### Storage Optimization

```solidity
// ‚úÖ CORRECT: Pack storage variables
contract Optimized {
    uint128 public s_price;      // 16 bytes
    uint64 public s_timestamp;   // 8 bytes
    uint64 public s_duration;    // 8 bytes (total: 32 bytes, 1 slot)

    address public s_seller;     // 20 bytes
    bool public s_active;        // 1 byte (total: 21 bytes, 1 slot)
}

// ‚ùå WRONG: Inefficient storage
contract Unoptimized {
    uint256 public s_price;      // 32 bytes
    uint256 public s_timestamp;  // 32 bytes
    uint256 public s_duration;   // 32 bytes (total: 96 bytes, 3 slots)
}
```

### Memory vs Storage

```solidity
// ‚úÖ CORRECT: Use memory for temporary data
function calculateFees(bytes32 m_listingId) public view returns (uint256) {
    Listing memory listing = s_listings[m_listingId];
    uint256 fee = (listing.price * s_takerFee) / BPS_DENOMINATOR;
    return fee;
}

// ‚úÖ CORRECT: Use storage for state updates
function updateListing(bytes32 m_listingId) internal {
    Listing storage listing = s_listings[m_listingId];
    listing.status = ListingStatus.Sold;
}
```

### Reduce External Calls

```solidity
// ‚úÖ CORRECT: Cache external call results
function distributePayment() internal {
    uint256 marketplaceFee = s_takerFee; // Cache storage read
    uint256 totalFee = (price * marketplaceFee) / BPS_DENOMINATOR;
    // Use totalFee multiple times
}

// ‚ùå WRONG: Multiple storage reads
function distributePayment() internal {
    uint256 totalFee = (price * s_takerFee) / BPS_DENOMINATOR;
    // Reading s_takerFee multiple times costs more gas
}
```

### Use Constants Library

```solidity
// ‚úÖ CORRECT: Use centralized constants
import {Constants} from "src/common/Constants.sol";

function validateFee(uint256 feeBps) internal pure returns (bool) {
    return Constants.isValidFee(feeBps);
}

function validateDuration(uint256 duration) internal pure returns (bool) {
    return Constants.isValidListingDuration(duration);
}
```

## üß™ **TESTING STANDARDS**

### Test Structure

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {Test, console2} from "forge-std/Test.sol";
import {ContractUnderTest} from "src/contracts/ContractUnderTest.sol";

contract ContractTest is Test {
    ContractUnderTest public contractUnderTest;

    address constant OWNER = address(0x123);
    address constant USER = address(0x456);

    function setUp() public {
        // Setup code
        vm.prank(OWNER);
        contractUnderTest = new ContractUnderTest();

        // Fund test accounts
        vm.deal(USER, 100 ether);
        vm.deal(OWNER, 100 ether);
    }

    // ============================================================================
    // POSITIVE TESTS
    // ============================================================================

    function test_FunctionName_Success() public {
        // Arrange
        vm.prank(USER);

        // Act
        contractUnderTest.someFunction();

        // Assert
        assertEq(contractUnderTest.someValue(), expectedValue);
    }

    // ============================================================================
    // NEGATIVE TESTS
    // ============================================================================

    function test_FunctionName_RevertInvalidInput() public {
        vm.prank(USER);
        vm.expectRevert(
            abi.encodeWithSelector(Contract__InvalidInput.selector)
        );
        contractUnderTest.someFunction();
    }

    // ============================================================================
    // FUZZ TESTS
    // ============================================================================

    function testFuzz_FunctionName(uint256 amount) public {
        vm.assume(amount > 0 && amount < 1000 ether);
        // Test implementation
    }
}
```

### Test Naming Convention

```solidity
// Pattern: test_FunctionName_Scenario
function test_CreateListing_Success() public { }
function test_CreateListing_RevertZeroPrice() public { }
function test_CreateListing_RevertNotOwner() public { }
function test_CreateListing_RevertAlreadyListed() public { }

// Fuzz tests: testFuzz_FunctionName
function testFuzz_CreateListing(uint256 price) public { }

// Coverage tests: Multiple scenarios
function test_Constructor_ZeroRoyalty() public { }
function test_Constructor_MaxRoyalty() public { }
```

### Test Organization

```solidity
contract ComprehensiveTest is Test {
    // ============================================================================
    // STATE VARIABLES & SETUP
    // ============================================================================

    // Test contracts and addresses

    function setUp() public { }

    // ============================================================================
    // CONSTRUCTOR TESTS
    // ============================================================================

    function test_Constructor_Success() public { }

    // ============================================================================
    // POSITIVE TESTS
    // ============================================================================

    function test_Function_Success() public { }

    // ============================================================================
    // NEGATIVE TESTS
    // ============================================================================

    function test_Function_RevertCondition() public { }

    // ============================================================================
    // EDGE CASES
    // ============================================================================

    function test_Function_EdgeCase() public { }

    // ============================================================================
    // FUZZ TESTS
    // ============================================================================

    function testFuzz_Function(uint256 value) public { }
}
```

### Foundry Test Commands

```bash
# Run all tests
forge test

# Run with verbosity
forge test -vv        # Show logs
forge test -vvv       # Show traces
forge test -vvvv      # Show step-by-step traces

# Run specific test file
forge test --match-path test/unit/exchange/ERC721NFTExchange.t.sol

# Run specific test function
forge test --match-test test_CreateListing_Success

# Gas report
forge test --gas-report

# Coverage
forge coverage

# Coverage with LCOV report
forge coverage --report lcov
```

## üìú **DEPLOYMENT PATTERNS**

### Deployment Script Structure

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import {Script, console2} from "forge-std/Script.sol";
import {ContractToDeploy} from "src/contracts/ContractToDeploy.sol";

contract DeployScript is Script {
    struct DeployedContracts {
        address contract1;
        address contract2;
    }

    function run() external {
        // Get deployment parameters
        address deployer = vm.envOr("DEPLOYER", msg.sender);
        address marketplaceWallet = vm.envOr("MARKETPLACE_WALLET", msg.sender);

        console2.log("=== Deploying Contracts ===");
        console2.log("Deployer:", deployer);
        console2.log("Marketplace wallet:", marketplaceWallet);

        // Deploy contracts
        vm.startBroadcast();
        DeployedContracts memory deployed = _deployContracts(marketplaceWallet);
        vm.stopBroadcast();

        // Save addresses
        _saveAddresses(deployed);
    }

    function _deployContracts(address marketplaceWallet)
        internal
        returns (DeployedContracts memory)
    {
        console2.log("\n1. Deploying contracts...");

        ContractToDeploy contract1 = new ContractToDeploy();
        contract1.initialize(marketplaceWallet, msg.sender);

        console2.log("   Contract1:", address(contract1));

        return DeployedContracts({
            contract1: address(contract1),
            contract2: address(0)
        });
    }

    function _saveAddresses(DeployedContracts memory deployed) internal {
        console2.log("\n=== Deployment Summary ===");
        console2.log("Contract1:", deployed.contract1);
    }
}
```

### Makefile Commands

```makefile
# Build contracts
make build

# Run tests
make test
make test-v     # Verbose
make test-vvv   # Maximum verbosity

# Format code
make format

# Start local blockchain
make start-anvil

# Deploy to local network
make deploy-all-local
```

## üé® **CODE STYLE**

### Solidity Configuration

```toml
# foundry.toml
[profile.default]
src = "src"
test = "test"
out = "out"
libs = ["lib"]
optimizer = true
optimizer_runs = 200

remappings = [
    '@openzeppelin/contracts=lib/openzeppelin-contracts/contracts'
]
```

### Formatting

```solidity
// Use forge fmt for automatic formatting
// Run: forge fmt

// ‚úÖ CORRECT: Consistent spacing and indentation
function createListing(
    address m_contractAddress,
    uint256 m_tokenId,
    uint256 m_price
) external {
    if (m_price == 0) {
        revert NFTExchange__PriceMustBeGreaterThanZero();
    }

    // Implementation
}

// ‚úÖ CORRECT: Clear struct formatting
Listing memory listing = Listing({
    contractAddress: m_contractAddress,
    tokenId: m_tokenId,
    price: m_price,
    seller: msg.sender,
    status: ListingStatus.Active
});
```

### Comments and Documentation

```solidity
/**
 * @title ContractName
 * @notice Brief description of contract purpose
 * @dev Technical implementation details
 * @author Author name
 */
contract ContractName {
    /**
     * @notice Creates a new listing for an NFT
     * @param m_contractAddress The NFT contract address
     * @param m_tokenId The token ID to list
     * @param m_price The listing price in wei
     * @dev Validates ownership and approval before creating listing
     */
    function createListing(
        address m_contractAddress,
        uint256 m_tokenId,
        uint256 m_price
    ) external {
        // Implementation
    }
}
```

## üéØ **CORE DEVELOPMENT PRINCIPLES**

1. **Security First**: Always prioritize security over convenience
2. **Gas Efficiency**: Optimize for gas without compromising readability
3. **Modular Design**: Use libraries for shared logic
4. **Clear Errors**: Use descriptive custom errors, never generic strings
5. **Comprehensive Events**: Emit events for all state changes
6. **Input Validation**: Validate all external inputs
7. **Test Coverage**: Aim for >90% test coverage
8. **Clean Architecture**: Separate concerns (base, core, libraries)
9. **Documentation**: Document all public/external functions
10. **Upgradeable**: Use initializable patterns for upgradeability

## üîç **INTERFACE PATTERNS**

```solidity
// ‚úÖ CORRECT: Clear interface hierarchy
interface IMarketplaceCore {
    function version() external pure returns (string memory);
    function contractType() external pure returns (string memory);
    function isActive() external view returns (bool);
}

interface IExchangeCore is IMarketplaceCore {
    function supportedStandard() external pure returns (string memory);
    function marketplaceWallet() external view returns (address);
    function getTakerFee() external view returns (uint256);
    function BPS_DENOMINATOR() external view returns (uint256);
}

// Implementation
contract ERC721NFTExchange is IExchangeCore {
    function version() public pure override returns (string memory) {
        return "1.0.0";
    }

    function contractType() public pure override returns (string memory) {
        return "ERC721Exchange";
    }

    function supportedStandard() public pure override returns (string memory) {
        return "ERC721";
    }
}
```

## üö® **COMMON MISTAKES TO AVOID**

1. **Don't use require/revert strings**: Use custom errors
2. **Don't skip input validation**: Always validate external inputs
3. **Don't ignore return values**: Check success of external calls
4. **Don't use tx.origin**: Use msg.sender for authentication
5. **Don't assume gas costs**: Always optimize for gas
6. **Don't hardcode values**: Use constants library
7. **Don't skip events**: Emit events for all state changes
8. **Don't use floating pragma**: Lock pragma version (^0.8.30)
9. **Don't skip natspec**: Document all public/external functions
10. **Don't mix concerns**: Keep contracts focused and modular

## ‚úÖ **PRE-COMMIT CHECKLIST**

- [ ] All tests pass (`forge test`)
- [ ] Code is formatted (`forge fmt`)
- [ ] No unused imports or variables
- [ ] Custom errors used (no require strings)
- [ ] Events emitted for state changes
- [ ] NatSpec documentation complete
- [ ] Gas optimizations applied
- [ ] Input validation present
- [ ] Security best practices followed
- [ ] Commit message follows conventional format
- [ ] Changes follow project architecture

---

**‚ö†Ô∏è Security Notice**: This is a smart contract project handling user assets. Always prioritize security, conduct thorough testing, and get professional audits before mainnet deployment.
